#type Domain @entity {
#  id: ID!                                                   # id is the nameHash of the actual domain
#  node: Bytes                                               # node is the nameHash() of the recursive, lower level domains. It could be just .eth (0x93cdeb....) or it could be mywallet.eth (0x8a075....)
#  label: Bytes                                              # label is the top level domain , i.e. it would be the hash of 'david' in david.mywallet.eth
#  owner: Bytes!
#  subDomains: [SubDomains!]! @derivedFrom(field: "domain")
#  pastOwners: [Bytes]!                                      # Past owners, populated by the Transfer event
#
#
#  domainName: String!       # todo fords help
#  resolver: Bytes!
#  ttl: Int!
#}
#
#type SubDomain @entity {
#  id: ID!
#  node: Bytes!
#  label: Bytes!
#  owner: Bytes!
#  subDomains: [SubDomains!]! @derivedFrom(field: "domain")
#  pastOwners: [Bytes]!                                      # Past owners, populated by the Transfer event
#
#
#  domainName: String!       # todo fords help
#  resolver: Bytes!
#  ttl: Int!
#}

# TODO - delete about, I believe the below will work, but uncertain right now

type Domain @entity {
  id: ID! # the node or the namehash of the domain/subdomain/subsubdomain
  node: Bytes # all domains sharing a node are all subdomains of that domain
  label: Bytes # this is what distingushes the subdomains within a domain
  resolver: Bytes
  ttl: Int

  # todo ford
  domainName: String # null if unknown

  owner: Bytes!
  pastOwners: [Bytes!]!

  subDomains: [Domain!]! @derivedFrom(field: "node") # if this domain has subdomains, their nodes will match this ID
}


# To query for a specific Event type, query with `where: {type: "AddrChanged"}`, and then only query `a` for null || non-null fields
type ENSEvent @entity {
  # Required by all events
  id: ID!                   # TODO make something noteworthy, but for now just do 0,1,2,3 etc.
  type: Event!              # Event type from basic resolver interface
  node: Bytes!              # Emitted by all events
  resolver: Bytes!          # Address of the resolver that emitted the event

  # Specific to event types
  a: Bytes                  # event AddrChanged
  name: String              # event NameChanged
  contentType: BigInt       # event ABIChanged
  x: Bytes                  # event PubkeyChanged
  y: Bytes                  # event PubkeyChanged
  indexedKey: String        # event TextChanged
  key: String               # event TextChanged
  hash: Bytes               # event ContenthashChanged
  interfaceID: Bytes        # event InterfaceChanged
  implementer: Bytes        # event InterfaceChanged
  owner: Bytes              # event AuthorisationChanged
  target: Bytes             # event AuthorisationChanged
  isAuthorized: Boolean     # event AuthorisationChanged
}

type Resolver @entity {
  id: ID!                   # Address of the resolver
  domain: Bytes!            # Domain the resolver is set to
  # todo - is it possible to derive what kind of resolver it is?
}

enum Event @entity {
  AddrChanged,
  NameChanged,
  ABIChanged,
  PubkeyChanged,
  Textchanged,
  ContenthashChanged,
  ContentChanged,
  InterfaceChanged,
  AuthorisationChanged,
}